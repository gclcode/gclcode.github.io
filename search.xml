<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网上商城项目(SSH)-SSH框架整合-1]]></title>
    <url>%2F2019%2F10%2F08%2F%E7%BD%91%E4%B8%8A%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE(SSH)-SSH%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88-1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最近老师带一个网上商城的SSH项目，自己想把项目的过程记录下来。一希望自己能将做项目中的一些BUG的解决方法分享给大家，二来可以帮助那些期末做课设的同学。本项目的SSH是指Spring4+Struts2+Hibernate5，项目中需要的jar包我会放在本章的百度网盘链接中。如果后续还需要添加jar包我会在需要添加的地方加以说明并会附上百度网盘链接。 开发环境说明 网上商城项目SSH项目开发环境,部分辅助软件不做陈述。 MySQL 5 Eclipse EE Java 1.8 Tomcat 9.0 下载需要的jar 我已经将将搭建环境的jar包进行了初步的整理，先把文件下载下来。 SSH整合Jar百度网盘地址 1https://pan.baidu.com/s/1Fv0JBF7p7DEqVjBKSCF9Eg 下载解压后的文件应该如下图所示，红框文件夹里的jar应该有49个。 搭建Spring4环境 在Eclipse里创建Dynamic Web Project项目。 项目名我这里起为SshTest。Tomcat 9.0也在这里设置，web.xml的版本设置为3.1。第一个页面设置完成后不要直接点Finish，请点Next。具体设置如下图。 点击Next两次到下图这个界面把Generate web.xml deploayment descriptor勾选上，然后再点击Finish。 将“全部的jar包”中49个jar包复制到项目/WebContent/WEB-INF/lib文件中。然后将bin所有jar添加项目依赖中。 在Java Resources下的src中创建beans.xml,内容如下所示。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;context:annotation-config /&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot; /&gt;&lt;/beans&gt; 配置spring监听器和log4j2监听器，编辑/WebContent/WEB-INF/web.xml,写入内容如下。 123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;SshTest&lt;/display-name&gt; &lt;!-- 1、添加log4j监听器，log4j监听器要放在前面 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/log4j2.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- log4j监听器配置结束，在Servlet3.0以上且Tomcat7.0以上的版本中，log4j不需要额外的配置了 --&gt; &lt;!-- 2、添加spring监听器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:beans.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- spring监听器配置结束 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 在Java Resources下的src中创建log4j2.xml,内容如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE xml&gt; &lt;Configuration status=&quot;off&quot; monitorInterval=&quot;1800&quot;&gt; &lt;properties&gt; &lt;property name=&quot;LOG_HOME&quot;&gt;/opt/logs/Test/log4j2Demo/logs&lt;/property&gt; &lt;property name=&quot;ERROR_LOG_FILE_NAME&quot;&gt;error&lt;/property&gt; &lt;/properties&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d %-5p (%F:%L) - %m%n&quot; /&gt; &lt;/Console&gt; &lt;RollingRandomAccessFile name=&quot;ErrorLog&quot; fileName=&quot;$&#123;LOG_HOME&#125;/$&#123;ERROR_LOG_FILE_NAME&#125;.log&quot; filePattern=&quot;$&#123;LOG_HOME&#125;/$&#123;ERROR_LOG_FILE_NAME&#125;.log.%d&#123;yyyy-MM-dd&#125;.gz&quot;&gt; &lt;PatternLayout pattern=&quot;%d %-5p (%F:%L) - %m%n&quot;/&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;100 MB&quot;/&gt; &lt;/Policies&gt; &lt;DefaultRolloverStrategy max=&quot;20&quot;/&gt; &lt;/RollingRandomAccessFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;!-- 3rdparty Loggers --&gt; &lt;logger name=&quot;org.springframework.core&quot; level=&quot;info&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.springframework.beans&quot; level=&quot;info&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.springframework.context&quot; level=&quot;info&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;org.springframework.web&quot; level=&quot;info&quot;&gt; &lt;/logger&gt; &lt;logger name=&quot;com.hafiz.www.controller&quot; level=&quot;error&quot; includeLocation=&quot;true&quot; additivity=&quot;false&quot;&gt; &lt;appender-ref ref=&quot;ErrorLog&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/logger&gt; &lt;root level=&quot;info&quot; includeLocation=&quot;true&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/Loggers&gt; &lt;/Configuration&gt; 创建cn.hncj.test包，并在包中创建Test类。 Test.java中写入的内容如下。 12345678910111213141516package cn.hncj.test;import java.util.Date;import org.junit.runner.RunWith;import javax.annotation.Resource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:beans.xml&quot;)public class Test &#123; @Resource private Date date; @org.junit.Test//测试spring的IOC环境 public void spingioc()&#123; System.out.println(date); &#125;&#125; 在Test.java中鼠标右键Run As&gt;Junit Test，如果控制台显示当前时间则说明spring环境配置成功。 搭建Hibernate环境 在Mysql中创建shop数据库，在shop中创建category数据表。 12345678910111213141516171819202122/*如果存在shop数据库则删除shop数据库 */DROP DATABASEIF EXISTS shop;/*创建shop数据库并设置编码方式为utf-8*/CREATE DATABASE shop DEFAULT CHARACTERSET utf8;/*创建shop数据库*/USE shop;/*如果存在category数据表则删除category数据表 */DROP TABLEIF EXISTS category;/*创建category数据表*/CREATE TABLE category ( /* 类别编号，自动增长 */ id INT NOT NULL auto_increment, /* 类别名称 */ type VARCHAR (20), /* 类别是否为热点类别，热点类别才有可能显示在首页*/ hot bool DEFAULT FALSE, /* 设置类别编号为主键*/ PRIMARY KEY (id)); category数据表格式如下。 id type hot 1 music 1 创建xml映射文件 在Java Resources下的src中创建hibernate.cfg.xml,特别注意的是代码块中的A和B。hibernate.cfg.xml内容如下所示。123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC &quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- property 元素用于配置Hibernate中的属性 键:值 --&gt; &lt;!-- hibernate.connection.driver_class : 连接数据库的驱动 --&gt; &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!-- hibernate.connection.username : 连接数据库的用户名 --&gt; &lt;property name=&quot;hibernate.connection.username&quot;&gt;root&lt;/property&gt; &lt;!-- hibernate.connection.password : 连接数据库的密码 --&gt; &lt;property name=&quot;hibernate.connection.password&quot;&gt;123456&lt;/property&gt; &lt;!-- A 下边的hibernate.connection.url是连接数据库的地址,路径，我这里的是本地路径，账号为root，密码是123456 --&gt; &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:mysql:///shop?useUnicode=true&amp;amp;characterEncoding=utf-8&lt;/property&gt; &lt;!-- ====================以上配置和Spring整合后可以删除================================ --&gt; &lt;!-- 操作数据库时,会 向控制台打印sql语句 --&gt; &lt;property name=&quot;show_sql&quot;&gt;true&lt;/property&gt; &lt;!--============================================================================ --&gt; &lt;!-- 打印sql语句前,会将sql语句先格式化 --&gt; &lt;property name=&quot;format_sql&quot;&gt;true&lt;/property&gt; &lt;!--============================================================================ --&gt; &lt;!-- hbm2ddl.auto: 生成表结构的策略配置 update(最常用的取值): 如果当前数据库中不存在表结构,那么自动创建表结构. 如果存在表结构,并且表结构与实体一致,那么不做修改 如果存在表结构,并且表结构与实体不一致,那么会修改表结构.会保留原有列. create(很少):无论是否存在表结构.每次启动Hibernate都会重新创建表结构.(数据会丢失) create-drop(极少): 无论是否存在表结构.每次启动Hibernate都会重新创建表结构.每次Hibernate运行结束时,删除表结构. validate(很少):不会自动创建表结构.也不会自动维护表结构.Hibernate只校验表结构. 如果表结构不一致将会抛出异常. --&gt; &lt;property name=&quot;hbm2ddl.auto&quot;&gt;update&lt;/property&gt; &lt;!--============================================================================ --&gt; &lt;!-- 数据库方言配置 --&gt; &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQL5InnoDBDialect&lt;/property&gt; &lt;!--============================================================================ --&gt; &lt;!-- 事务自动提交 --&gt; &lt;property name=&quot;hibernate.connection.autocommit&quot;&gt;true&lt;/property&gt; &lt;!-- B 这是引入ORM的映射文件将下文你创建的实体类的路径替换掉resourcez中的字符串 --&gt; &lt;mapping resource=&quot;cn/hncj/entity/Category.hbm.xml&quot; /&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 创建cn.hncj.entity包，并在包中创建Category类，写入的内容如下。 1234567891011121314151617181920212223242526272829303132333435363738394041package cn.hncj.entity;public class Category &#123; private Integer id; private String type; private Boolean hot; public Category() &#123; &#125; public Category(String type, Boolean hot) &#123; super(); this.type = type; this.hot = hot; &#125; public Category(Integer id, String type, Boolean hot) &#123; super(); this.id = id; this.type = type; this.hot = hot; &#125; @Override public String toString() &#123; return &quot;Category [id=&quot; + id + &quot;, type=&quot; + type + &quot;, hot=&quot; + hot + &quot;]&quot;; &#125; public Integer getId() &#123; return this.id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getType() &#123; return this.type; &#125; public void setType(String type) &#123; this.type = type; &#125; public Boolean getHot() &#123; return this.hot; &#125; public void setHot(Boolean hot) &#123; this.hot = hot; &#125;&#125; 在cn.hncj.entity包中创建Category.hbm.xml文件，写入的内容如下。 1234567891011121314151617&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;&gt;&lt;hibernate-mapping&gt; &lt;class name=&quot;cn.hncj.entity.Category&quot; table=&quot;category&quot;&gt; &lt;id name=&quot;id&quot; type=&quot;java.lang.Integer&quot;&gt; &lt;column name=&quot;id&quot; /&gt; &lt;generator class=&quot;native&quot; /&gt; &lt;/id&gt; &lt;property name=&quot;type&quot; type=&quot;java.lang.String&quot;&gt; &lt;column name=&quot;type&quot; /&gt; &lt;/property&gt; &lt;property name=&quot;hot&quot; type=&quot;java.lang.Boolean&quot;&gt; &lt;column name=&quot;hot&quot; /&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 创建cn.hncj.util包，并在包中创建HibernateSessionFactory类，写入的内容如下。 123456789101112131415package cn.hncj.util;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateSessionFactory &#123; private static final Configuration config; private static final SessionFactory factory; static &#123; config = new Configuration().configure(); factory = config.buildSessionFactory(); &#125; public static Session getSession() &#123; return factory.openSession(); &#125;&#125; 创建cn.hncj.service包，并在包中创建CategoryService接口类，写入的内容如下。 12345package cn.hncj.service;import cn.hncj.entity.Category;public interface CategoryService &#123; public void save(Category category); //用来测试Hibernate环境&#125; 在cn.hncj.service包中创建CategoryServiceImpl接口实现类用来实现CategoryService接口类未实现的方法，写入的内容如下。 123456789101112131415161718192021222324package cn.hncj.service;import org.hibernate.Session;import cn.hncj.entity.Category;import cn.hncj.util.HibernateSessionFactory;public class CategoryServiceImpl implements CategoryService&#123; @Override public void save(Category category) &#123; // 通过刚刚生成的sessionFactory获取session Session session = HibernateSessionFactory.getSession(); try &#123; // 手动事务 session.getTransaction().begin(); // 执行业务逻辑 session.save(category); // 手动提交 session.getTransaction().commit(); &#125; catch (Exception e) &#123; session.getTransaction().rollback(); throw new RuntimeException(e); &#125; finally &#123; session.close(); &#125; &#125;&#125; 重新编写cn.hncj.test包中的Test.java测试类如下。 12345678910111213141516171819202122232425package cn.hncj.test;import java.util.Date;import org.junit.runner.RunWith;import javax.annotation.Resource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import cn.hncj.entity.Category;import cn.hncj.service.CategoryService;import cn.hncj.service.CategoryServiceImpl;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:beans.xml&quot;)public class Test &#123; @Resource private Date date; @org.junit.Test//测试spring的IOC环境 public void spingioc()&#123; System.out.println(date); &#125; @org.junit.Test//测试Hibernate的开发环境，因为没有整合，可以直接new public void hihernate() &#123; CategoryService categoryService = new CategoryServiceImpl(); Category category = new Category(&quot;mantype&quot;, true); categoryService.save(category); &#125;&#125; 在Test.java中鼠标右键Run As&gt;Junit Test，如果控制台显示如下则说明hibernate环境可能配置成功。 如果shop数据库category数据表中插入下边的数据，则hibernate环境配置成功。 id type hot 1 mantype 1 整合Spring4和Hibernate5 在Java Resources下的src中创建jdbc.properties,将数据库的链接信息单独提取出来便于后期优化,内容如下所示。 1234jdbc.driverClassName=com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://106.15.73.43:3306/shop?useSSL=falsejdbc.username = rootjdbc.password = 123456 整合spring和hibernate需要在beans.xml添加配置如下。 配置数据源dataSource 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt;&lt;!-- 配置数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt; &lt;value&gt;$&#123;jdbc.driverClassName&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; &lt;value&gt;$&#123;jdbc.url&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;user&quot;&gt; &lt;value&gt;$&#123;jdbc.username&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;$&#123;jdbc.password&#125;&lt;/value&gt; &lt;/property&gt; &lt;!--连接池中保留的最小连接数。 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt; &lt;value&gt;5&lt;/value&gt; &lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt; &lt;value&gt;30&lt;/value&gt; &lt;/property&gt; &lt;!--初始化时获取的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt; &lt;value&gt;10&lt;/value&gt; &lt;/property&gt; &lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; &lt;property name=&quot;maxIdleTime&quot;&gt; &lt;value&gt;60&lt;/value&gt; &lt;/property&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt; &lt;value&gt;5&lt;/value&gt; &lt;/property&gt; &lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。 如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0 --&gt; &lt;property name=&quot;maxStatements&quot;&gt; &lt;value&gt;0&lt;/value&gt; &lt;/property&gt; &lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt; &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt; &lt;value&gt;60&lt;/value&gt; &lt;/property&gt; &lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot;&gt; &lt;value&gt;30&lt;/value&gt; &lt;/property&gt; &lt;!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效 保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试 获取连接失败后该数据源将申明已断开并永久关闭。Default: false --&gt; &lt;property name=&quot;breakAfterAcquireFailure&quot;&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!--因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的 时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable 等方法来提升连接测试的性能。Default: false --&gt; &lt;property name=&quot;testConnectionOnCheckout&quot;&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; 配置sessionFactory 12345&lt;!-- 配置sessionFactory --&gt;&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt;&lt;/bean&gt; 配置spring的事务管理器 1234&lt;!-- 配置spring事务管理器--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;&lt;/bean&gt; 配置advice 123456789&lt;!-- 配置advice（通知） --&gt;&lt;tx:advice id=&quot;advice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; 配置AOP切面(需要足以的是expression中service的路径，这个需要根据自己在hibernate中写的service路径来写) 12345678&lt;!-- 配置AOP切面 --&gt;&lt;aop:config&gt; &lt;!-- 配置哪些包的类要切入事务 --&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.hncj.service.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;pointcut&quot; /&gt; &lt;!-- 连接了上面的advice和上面的pointcut --&gt; &lt;!-- aop:pointcut要写在aop:advisor上面，否则会报错 --&gt;&lt;/aop:config&gt; 由于要测试spring和hibernate的整合需要重写cn.hncj.service包中的CategoryService接口类，写入的内容如下。 123456package cn.hncj.service;import cn.hncj.entity.Category;public interface CategoryService &#123; public void save(Category category); //用来测试Hibernate环境 public void update(Category category); //用来测试Spring和Hibernate整合后&#125; 由于我们重写了cn.hncj.service包中的CategoryService接口类，我们添加的update接口方法需要在CategoryServiceImlp中实现。CategoryServiceImlp.java写入的内容如下。 1234567891011121314151617181920212223package cn.hncj.service;import org.hibernate.Session;import org.hibernate.SessionFactory;import cn.hncj.entity.Category;public class CategoryServiceImpl implements CategoryService&#123; private SessionFactory sessionFactory; // 当需要使用sessoinFactory的时候，Spring会将sessionFactory注入进来 public void setSessionFactory(SessionFactory sessionFactory) &#123; this.sessionFactory = sessionFactory; &#125; protected Session getSession() &#123; // 从当前线程获取session，如果没有则创建一个新的session return sessionFactory.getCurrentSession(); &#125; @Override public void save(Category category) &#123; getSession().save(category); &#125; @Override public void update(Category category) &#123; getSession().update(category); &#125;&#125; 在Spring的配置文件beans.xml中配一下这个CategoryService。 12345&lt;!-- 测试spring与hibernate整合结果 --&gt;&lt;bean id=&quot;categoryService&quot; class=&quot;cn.hncj.service.CategoryServiceImpl&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;!-- 依赖的sessionFactory用我们之前配好的sessionFactory --&gt;&lt;/bean&gt; 重新Java Resources下的src的beans.xml,内容如下所示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;context:annotation-config /&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot; /&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt; &lt;value&gt;$&#123;jdbc.driverClassName&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; &lt;value&gt;$&#123;jdbc.url&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;user&quot;&gt; &lt;value&gt;$&#123;jdbc.username&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;$&#123;jdbc.password&#125;&lt;/value&gt; &lt;/property&gt; &lt;!--连接池中保留的最小连接数。 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt; &lt;value&gt;5&lt;/value&gt; &lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt; &lt;value&gt;30&lt;/value&gt; &lt;/property&gt; &lt;!--初始化时获取的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt; &lt;value&gt;10&lt;/value&gt; &lt;/property&gt; &lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; &lt;property name=&quot;maxIdleTime&quot;&gt; &lt;value&gt;60&lt;/value&gt; &lt;/property&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt; &lt;value&gt;5&lt;/value&gt; &lt;/property&gt; &lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。 如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0 --&gt; &lt;property name=&quot;maxStatements&quot;&gt; &lt;value&gt;0&lt;/value&gt; &lt;/property&gt; &lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt; &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt; &lt;value&gt;60&lt;/value&gt; &lt;/property&gt; &lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot;&gt; &lt;value&gt;30&lt;/value&gt; &lt;/property&gt; &lt;!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效 保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试 获取连接失败后该数据源将申明已断开并永久关闭。Default: false --&gt; &lt;property name=&quot;breakAfterAcquireFailure&quot;&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!--因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的 时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable 等方法来提升连接测试的性能。Default: false --&gt; &lt;property name=&quot;testConnectionOnCheckout&quot;&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置sessionFactory --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置spring事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置advice（通知） --&gt; &lt;tx:advice id=&quot;advice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置AOP切面 --&gt; &lt;aop:config&gt; &lt;!-- 配置哪些包的类要切入事务 --&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.hncj.service.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;pointcut&quot; /&gt; &lt;!-- 连接了上面的advice和上面的pointcut --&gt; &lt;!-- aop:pointcut要写在aop:advisor上面，否则会报错 --&gt; &lt;/aop:config&gt; &lt;!-- 测试spring与hibernate整合结果 --&gt; &lt;bean id=&quot;categoryService&quot; class=&quot;cn.hncj.service.CategoryServiceImpl&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;!-- 依赖的sessionFactory用我们之前配好的sessionFactory --&gt; &lt;/bean&gt;&lt;/beans&gt; 重新编写cn.hncj.test包中的Test.java测试类如下。 12345678910111213141516171819202122232425262728293031package cn.hncj.test;import java.util.Date;import org.junit.runner.RunWith;import javax.annotation.Resource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import cn.hncj.entity.Category;import cn.hncj.service.CategoryService;import cn.hncj.service.CategoryServiceImpl;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations=&quot;classpath:beans.xml&quot;)public class Test &#123; @Resource private Date date; @org.junit.Test//测试spring的IOC环境 public void spingioc()&#123; System.out.println(date); &#125;// @org.junit.Test//测试Hibernate的开发环境，因为没有整合，可以直接new// public void hihernate() &#123;// CategoryService categoryService = new CategoryServiceImpl();// Category category = new Category(&quot;mantype&quot;, true);// categoryService.save(category);// &#125; @Resource private CategoryService categoryService; @org.junit.Test // 测试Hibernate和Spring整合后 public void hibernateAndSpring() &#123; categoryService.update(new Category(1, &quot;girltype&quot;, true)); // categoryService通过Spring从上面注入进来的 &#125;&#125; 在Test.java中鼠标右键Run As&gt;Junit Test，如果控制台显示如下则说明spring和hibernate整合可能成功。 如果shop数据库category数据表中插入下边的数据，则说明spring和hibernate整合成功。 id type hot 1 girltype 1 搭建Struts2环境并整合Spring4 在web.xml文件对Struts2进行配置，web.xml配置如下。 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt; &lt;display-name&gt;SshTest&lt;/display-name&gt; &lt;!-- 1、添加log4j监听器，log4j监听器要放在前面 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfiguration&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/log4j2.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- log4j监听器配置结束，在Servlet3.0以上且Tomcat7.0以上的版本中，log4j不需要额外的配置了 --&gt; &lt;!-- 2、添加spring监听器 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:beans.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- spring监听器配置结束 --&gt; &lt;!-- 6、添加Struts2的核心过滤器。注意对应的是2.5.16版本 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt;&lt;/web-app&gt; 创建cn.hncj.action包，并在包中创建CategoryAction类，写入的内容如下。 123456789101112131415161718192021222324252627282930313233package cn.hncj.action;import com.opensymphony.xwork2.ActionSupport;import cn.hncj.entity.Category;import cn.hncj.service.CategoryService;public class CategoryAction extends ActionSupport&#123; private static final long serialVersionUID = 1L; private CategoryService categoryService; // 设置categoryService是为了很直观的看出与Spring整合前后的不同 private Category category; // 设置一个私有成员变量接收url带过来的参数，注意下面要写好get和set方法 public void setCategoryService(CategoryService categoryService) &#123; this.categoryService = categoryService; &#125; public String update() &#123; System.out.println(&quot;----update----&quot;); System.out.println(categoryService);// 由于已经和Spring整合，所以可以拿到这个categoryService了，打印出来就不是null了 categoryService.update(category); // 新加一条语句，来更新数据库 return &quot;index&quot;; &#125; public String save() &#123; System.out.println(&quot;----save----&quot;); System.out.println(categoryService);// 整合前后输出不同 categoryService.save(category); return &quot;index&quot;; &#125; public Category getCategory() &#123; return category; &#125; public void setCategory(Category category) &#123; this.category = category; &#125;&#125; 在Java Resources下的src中创建struts.xml文件，内容如下。 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.5//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.5.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;test&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt; &lt;global-allowed-methods&gt;execute,input,back,cancel,browse,update,save,delete,list,index&lt;/global-allowed-methods&gt; &lt;!-- class对应的是Spring中配置该Action的id值，因为要交给Spring管理 --&gt; &lt;action name=&quot;category_*&quot; class=&quot;cn.hncj.action.CategoryAction&quot; method=&quot;&#123;1&#125;&quot;&gt; &lt;result name=&quot;index&quot;&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 在beans.xml文件中添加categoryaction配置。 12345&lt;!-- 把CategoryAction和它的依赖交给Spring管理 --&gt;&lt;bean id=&quot;categoryAction&quot; class=&quot;cn.hncj.action.CategoryAction&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;categoryService&quot; ref=&quot;categoryService&quot; /&gt; &lt;!-- 依赖的categoryService用上面和Hibernate整合时配置好的categoryService --&gt;&lt;/bean&gt; 完整的web.xml文件信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;context:annotation-config /&gt; &lt;bean id=&quot;date&quot; class=&quot;java.util.Date&quot; /&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt; &lt;value&gt;$&#123;jdbc.driverClassName&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; &lt;value&gt;$&#123;jdbc.url&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;user&quot;&gt; &lt;value&gt;$&#123;jdbc.username&#125;&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;$&#123;jdbc.password&#125;&lt;/value&gt; &lt;/property&gt; &lt;!--连接池中保留的最小连接数。 --&gt; &lt;property name=&quot;minPoolSize&quot;&gt; &lt;value&gt;5&lt;/value&gt; &lt;/property&gt; &lt;!--连接池中保留的最大连接数。Default: 15 --&gt; &lt;property name=&quot;maxPoolSize&quot;&gt; &lt;value&gt;30&lt;/value&gt; &lt;/property&gt; &lt;!--初始化时获取的连接数，取值应在minPoolSize与maxPoolSize之间。Default: 3 --&gt; &lt;property name=&quot;initialPoolSize&quot;&gt; &lt;value&gt;10&lt;/value&gt; &lt;/property&gt; &lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt; &lt;property name=&quot;maxIdleTime&quot;&gt; &lt;value&gt;60&lt;/value&gt; &lt;/property&gt; &lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt; &lt;property name=&quot;acquireIncrement&quot;&gt; &lt;value&gt;5&lt;/value&gt; &lt;/property&gt; &lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但由于预缓存的statements 属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。 如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0 --&gt; &lt;property name=&quot;maxStatements&quot;&gt; &lt;value&gt;0&lt;/value&gt; &lt;/property&gt; &lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt; &lt;property name=&quot;idleConnectionTestPeriod&quot;&gt; &lt;value&gt;60&lt;/value&gt; &lt;/property&gt; &lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot;&gt; &lt;value&gt;30&lt;/value&gt; &lt;/property&gt; &lt;!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效 保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试 获取连接失败后该数据源将申明已断开并永久关闭。Default: false --&gt; &lt;property name=&quot;breakAfterAcquireFailure&quot;&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;!--因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交的 时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable 等方法来提升连接测试的性能。Default: false --&gt; &lt;property name=&quot;testConnectionOnCheckout&quot;&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置sessionFactory --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置spring事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置advice（通知） --&gt; &lt;tx:advice id=&quot;advice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;delete*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置AOP切面 --&gt; &lt;aop:config&gt; &lt;!-- 配置哪些包的类要切入事务 --&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* cn.hncj.service.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;advice&quot; pointcut-ref=&quot;pointcut&quot; /&gt; &lt;!-- 连接了上面的advice和上面的pointcut --&gt; &lt;!-- aop:pointcut要写在aop:advisor上面，否则会报错 --&gt; &lt;/aop:config&gt; &lt;!-- 测试spring与hibernate整合结果 --&gt; &lt;bean id=&quot;categoryService&quot; class=&quot;cn.hncj.service.CategoryServiceImpl&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;!-- 依赖的sessionFactory用我们之前配好的sessionFactory --&gt; &lt;/bean&gt; &lt;!-- 把CategoryAction和它的依赖交给Spring管理 --&gt; &lt;bean id=&quot;categoryAction&quot; class=&quot;cn.hncj.action.CategoryAction&quot; scope=&quot;prototype&quot;&gt; &lt;property name=&quot;categoryService&quot; ref=&quot;categoryService&quot; /&gt; &lt;!-- 依赖的categoryService用上面和Hibernate整合时配置好的categoryService --&gt; &lt;/bean&gt;&lt;/beans&gt; 在WebContent文件夹下创建index.jsp用来测试struts2和Spring4整合的环境。inde.jsp的内容如下。 12345678910111213&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Spring和Struts整合测试&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=&quot;category_update.action?category.id=9&amp;category.type=gcl&amp;category.hot=true&quot;&gt;访问update&lt;/a&gt;&lt;br&gt; &lt;a href=&quot;category_save.action?category.type=gcl&amp;category.hot=true&quot;&gt;访问save&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 在tomcat9.0服务器上运行index.jsp,点击两个链接输出结果如下图所示。并且数据库有数据的更新和添加则struts2和spring4的整合成功了。 如果有报错请先检查你的数据库中是否有id=9的数据信息，因为我在index.jsp中设定了category.id=9。 提示说明 本章的SSH整合项目的目录结构如下图所示。 本章的SSH整合项目我已经上传到百度网盘了，链接放到下边。 1https://pan.baidu.com/s/12xlczc_sTbVxnmxuJHESpA 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
      <categories>
        <category>网站开发</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪分布式Hadoop的datanode无法启动]]></title>
    <url>%2F2019%2F09%2F19%2F%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8FHadoop%E7%9A%84datanode%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇主要介绍如何解决搭建的伪分布hadoop启动时无法启动datanode节点的问题。最近由于学习需要用到Hadoop的伪分布式自己搭建了一个，没想到在测试时报了错。经过我在网上的不断尝试终于找到了解决办法，希望我写的这篇博客能够帮助大家解决问题。 查找无法启动的原因 想要知道datanode节点无法启动的原因就，必须知道到底是哪个地方报错了。这个时候就需要找到datanode的log文件，查看启动报错的具体信息。 Datanode的log存放地址 报错的具体原因 解决无法启动的原因 经过查看日志文件发现是由于DataNode和NameNode的clusterID不匹配导致的，在hdfs-site.xml里配置的dfs.datanode.data.dir路径下有个VERSION文件，需要把里面的clusterID修改成和dfs.namenode.name.dir路径下的VERSION里的clusterID一致。 Datanode无法的原因 经过查找出错源头是因为执行namenode格式化命令(hdfs namenode -format)时会重新生成namenode的clusterID，而datanode的clusterID还是旧的没有改变。 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>centos-7</tag>
        <tag>datanode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在VMware中CentOS-7设置静态IP]]></title>
    <url>%2F2019%2F08%2F04%2F%E5%9C%A8VMware%E4%B8%ADCentOS-7%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这篇主要介绍如何设置VMware虚拟机中的CentOS-7的静态IP。写这篇的原因是在学习Hadoop的时候配置虚拟Linux遇到了网络配置问题，希望我写的这篇博客能够帮助大家解决问题。 VMware和CentOS-7的安装 VMware和CentOS-7的安装不是我们的重点，所以我们就跳过。如果不会的童鞋可以按照下面的网页链接进行安装。 VMware15（32/64）位下载地址： 1https://pan.baidu.com/s/1bTFt1hhPHIZ5YFbatN95bw 提取码: t4v3 VMware15（32/64）位安装教程： 1https://mp.weixin.qq.com/s/28fb8SQgUz2lcHSCCk_UBg CentOS 7/64位下载地址： 1pan.baidu.com/s/1HLbQrE5M2UW1S7KFBuFLZQ 提取码: 24d4 CentOS 7/64位安装教程： 1https://mp.weixin.qq.com/s/0X1fq8xJjBQ5eKU8gQllWw 关闭VMware的DHCP设置 打开VMware依次打开编辑-&gt;虚拟机网络配置。 选择VMnet8，取消勾选”使用本地DHCP服务将IP地址分配给虚拟机”选项。 点击”NAT设置”查看一下GATEWAY地址。 虚拟机裸机网络设置 点击虚拟机右键设置，按照下图设置即可。移除声卡和打印机可以随意。 关闭CentOS-7防火墙 使用firewall-cmd -stat命令查看Linux的防火墙是否关闭。 如果回显如下图，则已经关闭了不需要在进行调整。 如果回显是running则说明防火墙正在运行，需要依次运行下边的命令。12systemctl stop firewalld.service # 关闭防火墙systemctl disable firewalld.service # 禁止开机启动防火墙 设置CentOS-7网关 打开CentOS，使用vim /etc/sysconfig/network命令进行编辑，添加下面的信息。123NETWORKING=yesHOSTNAME=localhost.localdomainGATEWAY=192.168.44.2 #设置成你在虚拟机网络配置查看到的网关 设置CentOS-7静态IP 使用ifconfig命令查看网卡名，如下图我的网卡名为eno16777736。 使用vim /etc/sysconfig/network-scripts/ifcfg-eno16777736命令编辑IP地址要求此IP与VMware的VMnet8子网IP在同一网段，打开后注释或删除原来的ONBOOT和BOOTPROTO。添加下边的参数。 123456ONBOOT=yesBOOTPROTO=staticNETNASK=255.255.255.0 # 子网掩码GATEWAY=192.168.1.1 # 网关DNS1=192.168.1.1 # 可以设置为网关IPADDR=192.168.44.100 #与VMnet8同一网段 更改主机名以及重启网络并检查是否设置正确 使用下边的命令更改主机名 1hostnamectl set-hostname 主机名 # 主机名不能有下划线 使用下边的命令重启网络 1systemctl restart network 使用ping命令检查网络是否设置正常 内网检查 电脑本机ip 192.168.31.219 虚拟机CentOS-7ip 192.168.44.100 外网检查 通过ping www.baidu.com检查是否能连接外网 如果有错误请从新设置 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>centos-7</tag>
        <tag>vmware</tag>
        <tag>static ip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github搭建博客(四)]]></title>
    <url>%2F2019%2F07%2F19%2F%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A24%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是第三篇介绍通过Hexo博客框架在GitHub上创建个人博客网站的教程，希望能大家有所帮助。这篇博客主要介绍本地编辑软件Sublime的安装和本地Hexo编辑以及Hexo同步到GitHub的教程。 Sublime的安装 Sublime是什么 Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。 Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。 Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。 在这里我们主要是用Sublime来编辑.md文件和.yml格式的文件。 Sublime官方网站 1http://www.sublimetext.com/ 本地博客文章的创建与编辑 文章的创建 在上篇的Blog文件下文门采用hexo init “博客名”(可随意)命令生成了，一个本地的博客文件。进入这个文件中使用鼠标右键打开Git Bash Here后使用下边的命令。 创建博客新文章，使用Sublime打开路径为\博客名\source_posts\文章名.md进行编辑。 1Hexo new &quot;文章名&quot; 如果大家对Hexo命令不太熟悉的话可以点击Hexo命令查看。 本地Hexo同步到GitHub 配置_config.yml文件(只标注了需要更改的项目) 站点配置 12345# Sitetitle: Jade // 网站标题subtitle: Jade // 网站副标题description: Jade // 网站描述author: Jade // 您的名字 URL配置 12# URLurl: http://blogwenbo.com/ // https://+仓库名 Git部署配置 1234deploy:type: git // 类型repo: http://github.com/gclcode/gclcode.github.io.git // 仓库链接地址branch: master // 分支 博客配置文件调试完成，上传测试(按照顺序执行下列命令) 配置用户名和密码 12git config --global user.email &quot;GitHub账号绑定的邮箱地址&quot;git config --global user.name &quot;GitHub账号名&quot; 清理博客缓存 1heox clean 生成静态博客文件 1hexo generate 部署博客到远端,如果出现保持请点击解决办法进行查看,如果没有报错那就是成功了。 1hexo deploy 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github搭建博客(三)]]></title>
    <url>%2F2019%2F07%2F18%2F%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A23%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是第三篇介绍通过Hexo博客框架在GitHub上创建个人博客网站的教程，希望能大家有所帮助。这篇博客主要介绍本地Hexo框架的安装。 Hexo框架的安装 详细操作可以点击Hexo进行查看。 1https://hexo.io/zh-cn/ 新建Blog(可以自定义名)文件夹后在文件夹中鼠标右键打开Git Bash Here后按照顺序使用下边的命令。 安装Hexo框架 1npm install hexo-cli -g 初始化博客文件 1hexo init &quot;博客名(可随意)&quot; 进入初始化成功的博客文件 1cd &quot;博客名(初始化时的博客文件名)&quot; 安装博客依赖 1npm install 在本地启动你的博客 1hexo server 由于Hexo默认安装的是官方主题，本机4000端口的网页样式应该与下图一样。 温馨提醒 这期是在本地生成了静态的官方博客框架，想要将您的博客同步到远端，请等待下一期更新。 点击本地博客查看本机已经安装好的博客框架。 1http://localhost:4000 如果大家对Hexo命令不太熟悉的话可以点击Hexo命令查看。 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github搭建博客(二)]]></title>
    <url>%2F2019%2F07%2F17%2F%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A22%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是第二篇介绍通过Hexo博客框架在GitHub上创建个人博客网站的教程，希望能大家有所帮助。这篇博客主要介绍GitHub仓库的创建和GitHub SSH的配置。 GitHub仓库的创建 什么是GitHub仓库 GitHub是一个基于git的代码托管平台,付费用户可以建私人仓库，我们一般的免费用户只能使用公共仓库，也就是代码要公开。 登录GitHub官方网站 1https://github.com/ 登录你已经创建并验证过的账号，点击Repositories后在点击New。 填写仓库信息: 为了方便以后的操作，仓库的链接格式可以按照图片中的格式写。 配置GitHub SSH 为什么要配置SSH: 如果不配置SSH的话，谁都有权限提交代码到你的远程库。 也可以用HTTPS的方式克隆代码，但是每次提交到远程的是时候，需要输入账号密码(不推荐)。 配置好ssh之后，每次提交到远程的是时候就不需要每次都输入账号密码了。 在任意位置鼠标点击右键点击Git Bash Here，执行下面的命令点击三次回车即可，由于我的电脑已经配置过了，下面我们只讲命令和注意事项。 1ssh-keygen -t rsa -C &quot;你GitHub账号的邮箱地址&quot; 继续在Git Bash Here依次输入下面的三个命令： 进入ssh文件目录。 1cd ~/.ssh 查看是否存在id_rsa.pub文件。 1ls 查看并复制id_rsa.pub中key的信息，文件具体信息如下。 1vi id_rsa.pub 打开GitHub官网按照下图片操作 将在id_rsa.pub中复制的信息粘贴到Key中，Title随便写就可以建议写用户名,完成后点击Add SSH Key即可。 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>shh</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github搭建博客(一)]]></title>
    <url>%2F2019%2F07%2F16%2F%E4%BD%BF%E7%94%A8github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A21%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这是我第一次搭建博客，为了方便身边的小伙伴搭建自己的博客。我打算把博客搭建的流程记录下来，我这个博客是通过github使用hexo博客框架搭建起来的。这篇博客主要介绍Node.js的下载及安装和GitHub账号的注册以及Git For Windows的下载安装。 为什么要安装Node.js和Git For Windows: 我们使用的博客框架是Hexo，Hexo是一个快速、简洁且高效的博客框架。 Hexo框架必须由Node.js和Git For Windows的支持。 安装Hexo博客框架的具体的要求请进入Hexo官方文档了解：1https://hexo.io/zh-cn/docs/index.html 由于Git For Windows的下载速度十分缓慢，我在这里已经准备好了百度网盘的传送门： Git For Windows和Node.js的百度网盘安装包1网盘链接：https://pan.baidu.com/s/1kNqnMaN5q5k70he3I5Ue5Q 提取码：keyi Node.js的下载及安装 Node.js是什么： Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 Node.js 的包管理器 npm，是全球最大的开源库生态系统。 V10.16.0版本的Node.js的下载链接： 1https://nodejs.org/dist/v10.16.0/node-v10.16.0-x64.msi Node.js的官方下载网址： 1https://nodejs.org/zh-cn/ Node.js的下载 Node.js的安装和验证 Node.js安装过程和普通的桌面应用程序一样一直点下一步，直到完成。 在cmd命令行窗口中，使用node -v命令查看安装的Node.js的版本，如果你获得下面输出结果，说明你已经成功安装了Node.js。 GitHub账号的注册 GitHub是什么： GitHub是一个基于网站和云的服务，可以帮助开发人员存储和管理他们的代码，以及跟踪和控制对代码的更改。 GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开或私有的代码仓库，但付费用户支持更多功能 GitHub也提供了一些方便社会化共同软件开发的功能，即一般人口中的社群功能，包括允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。 GitHub的官方网址： 1https://github.com/ 注册GitHub： 按照图片上的提示写入用户名，邮箱和密码后，点击Sign up for GitHub完成注册的第一步。 完成图片验证后按照下边的图片选择免费版即可，点击Continue完成注册的第二步。 下边的三个问题随便填写后点击Submit或者直接点击skip this step即可完成GitHub账号的注册。 完成注册后的用户界面如下图所示，这时候的账号还不能立即使用。还需要验证你的邮箱，打开邮箱点击GitHub放给我们的邮件中的链接即可验证邮箱。 Git For Windows的下载及安装 Git是什么： Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目 Git的官方下载地址 1https://git-scm.com/downloads 下载Git,点击红框即可下载Git。 Git的安装和验证 Git安装过程和普通的桌面应用程序一样一直点下一步，直到完成。 在cmd命令行窗口中，使用git –version命令查看安装的Git的版本，如果你获得下面输出结果，说明你已经成功安装了Git。 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Hexo命令的问题]]></title>
    <url>%2F2019%2F07%2F15%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BAHexo-deploy%E5%91%BD%E4%BB%A4%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在使用Hexo工具来完善我们的博客时，我们有时也会忘记一些基础的命令。这篇博客是我在安装部署Hexo时遇到的问题和解办法，希望对大家有所帮助。 使用Hexo deploy命令出错 第一种出错情况如下 1ERROR Deployer not found: 通常使用该命令解决此问题 1npm install hexo-deployer-git --save 第二种出错情况如下 1ERROR Deployer not found: git 通常使用该命令解决此问题 1npm install hexo-server --save 静态博客Hexo命令流程 生成一个博客日志 1hexo new 文件名 清理博客缓存 1heox clean 生成静态博客文件 1hexo generate 在本地运行博客,默认端口为4000 1hexo server 如果本机的4000端口已经被使用，可以通过下边的命令使用其他端口 1hexo server -port 未被使用的端口号 部署博客到远端 1hexo deploy 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[帅气小哥哥的专属博客]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%B8%85%E6%B0%94%E5%B0%8F%E5%93%A5%E5%93%A5%E7%9A%84%E4%B8%93%E5%B1%9E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一次搭建自己的博客，有许多地方还不太熟悉。希望自己在学习知识的同时能够坚持写博客，提高自己的总结能力，把学习知识的过程中遇到的问题及解决方法和技术感悟总结出来，不仅可以分享给有需要的人也可以为日后遇到的问题提供参考。 本文作者: Jade版权声明： 未经授权禁止使用，转载请注明出处！]]></content>
  </entry>
</search>
